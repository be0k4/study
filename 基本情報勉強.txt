基本情報勉強
	目標
	A科目7割
	B科目7割
	
科目Aについて、インプットはyoutube動画、過去問は過去問道場で行うように
科目Bは必要があれば参考書を買う

基礎理論
n進数
	・コンピュータは0と1の2進数で処理を行っている
	・コンピュータが扱う最小の単位(0か1が入る)　bit  8bit = 1byte
		例えば文字は文字コードによって　あ　シフトJISコード「1000 0010 10101 0000」と表現される
			文字化けは異なる文字コードをあてはめることによって起きている

	・n進数の桁の重みを「基数」と呼ぶ
		整数部の重みはn^0、n^1・・・
		少数部の重みはn^-1、n^-2・・・
			-の累乗はn^-1 = 1/ n^1
基数変換
	・n進数を10進数に変換
		各桁の重み　×　個数 の和
	  		ex)1010.001(2) = 2^3 + 2^1 + 2^-3 = 8 + 2 + 1/8 = 10.125
			   137.4(8) = 8^2 + 8^1*3 + 1*7 + 8^-1*4 = 95.5
			
			★分母をそろえたり、約分したりできるように1/n^の形で計算するとよい

	★10 → 8・16の場合は1度2進数に変換する
	・10進数を2進数に変換
		整数部分を商が0になるまで2で割り算して、下から上に
		小数部分を積が1になるまで2で掛け算して、整数部を上から下に

		★10進数を2進数に直す際にすでに分数とかで変換しやすい数値になっていることもある　例)1/2^-6 = 0.000001


	・2進数を8進数に変換
		小数点をベースに3桁区切りに分け、各ブロックを8進数にする
			★小数点の部分はn^-1ではなく、整数部と同じようにn^1と計算するので注意
			ex)1101011.01 = 001 101 011 .010 =  1 5 3.2

	・8進数を2進数に変換
		各桁を2進数3桁で表現
			ex) 63.5 = 110 011 .101

	・2進数を16進数に変換
		小数点をベースに4桁区切り
			ex) 1101101.001101 = 0110 1101 .0011 0100 = 6 13  3 2 = 6D34

	・16進数を2進数に変換
		各桁を2進数4桁で表現
		ex)D4.C = 13 4 . 12 = 1101 0100 .1100

2進数の演算
	・2進数の引き算
		コンピュータは引き算を行えないので、負の数の足し算を行う。負の数は2の補数で表現する。
		★2の補数は「正の2進数をビット反転させて+1」で求める
			★【2の補数の特徴】
			コンピューターはマイナスを先頭ビットで判断することがある。(1：負、0:正)
			2の補数に同じ操作を行うと元々の正の数になる。
			負の数を10進数にするときは、正の数に直してあげれば計算できるが、直接計算することはできないので注意

	・2進数の掛け算
		・論理左シフト(符号は考慮しない)
			空いたスペースに0を入れる。
			1がはみ出るとオーバーフロー。
			ex) 00101010　2ビット左論理シフト(×2^2)→  (00)10101000
			    01000000　　　　　　　〃　　　　　　→  (01)00000000  オーバーフロー。
		・算術左シフト
			符号ビットを除いて、7ビットで空いたスペースに0を入れる。最後に符号ビットを加えて8ビットにする。
			符号ビットと異なる数がはみ出るとオーバーフロー
			ex) 11101000　2ビット左算術シフト	→  1(11)0100000
			    11011110				→  1(10)1111000　オーバーフロー。
	・2進数の割り算
		・論理右シフト
			空いたスペースに0を入れる。
			はみ出た分は余り
			01001000	→	00010010(00)
		・算術右シフト
			符号ビットを除いて、7ビットで空いたスペースに符号ビットを入れる。最後に符号ビットを加えて8ビットにする。
			はみ出た分は余り
			11101000	→	11111010(00)
数の表現と誤差
	①ビット数で表現できる数値の範囲外
	②桁数指定したときにあふれる
	③割り切れない
	④アバウトな数同士で計算した結果、元の正確な数値の計算結果とズレがでる
	5丸め誤差


論理演算・論理回路
	・ド・モルガンの法則
		・と+を変換すると否定の棒が分割・結合

	・論理回路
		2つの入力に対アして、どのような場合に1を出力するかの判定方法が回路ごとに違う
		・は「かつ」　+は「または」を意味する
		1.論理積回路 A・B　1と1で1を出力
		2.論理和回路 A + B　どちらかが1なら1を出力
		3.否定回路 入力値の逆を出力
		4.排他的論理和　0と1で1を出力
	

		★mil記号の問題は、0と1の入力値に対して、各回路を通した結果どうなるかを表で調べることでどの回路かが分かる
		論理演算の場合も同様で、2つの入力に対して0と1を代入した結果を調べて回路が分かる
	
	・半加算器
		2進数の足し算を疑似的に行う。下位桁の繰上りを考慮できない。
	
	入力値x.y 　出力値c.s
	1,1	    1,0
	1,0	    0,1
	0,1	    0,1
	0,0	    0,0
	Cは論理積、Sは排他的論理和である。つまりこれらの回路は足し算を行っているのではなく、桁ごとに論理演算を行っているだけ。

	・全加算器
		名前の通り全加算する。下位桁となる半加算器から繰上りがあるため、入力値が3つある。

確率・統計
	・nPr = n! / (n -r)!
		並び順を区別してn個からr個取り出す組み合わせ
	
	・nCr = n! / r!(n - r)!
		並び順を区別せずにn個からr個取り出す組み合わせ

	・条件付確率 P(A|B) = P(A&&B)/P(B)
		事象Bが起きた時事象Aが起きる確率

	・期待値
		各事象の確率 * 得られる値　の合計
		ex) サイコロの目 ひとつあたり100円がもらえるゲーム　の報酬の期待値
		 1/6 * 100 + 1/6 * 200 + 1/6 * 300 + 1/6 * 400 + 1/6 * 500 + 1/6 * 600	= 350
	
行列計算
	・行列同士の足し算引き算
		対応するマス同士で計算するだけ

	・行列 * スカラ
		全マスをスカラで掛けるだけ

	・行列同士の掛け算
		★A(3 * 2) * B(2 * 3)　内側の数字(Aの列とBの行)が同じ場合計算可能
		行 * 列(対応する数同士で掛け算)の和で一マスずつ求める
		A 123   *   B 12   = 12 28
		  456	      34     49 64
			      56	
状態遷移図
	与えられた入力の結果、出力がどうなるかを遷移図を見ながら考えるだけ

ビット操作
	・ビットの取り出し
		取り出す桁数だけ1をたてたビット列を作り、元のビット列との論理積を出す

	・ビット反転
		反転する桁数だけ1をたてたビット列を作り、元のビット列と排他的論理和を出す

ハフマン符号化
	子二つの使用頻度の合計を親とし、使用頻度の低い順に2組ずつ文字を枝分かれさせて並べる（木構造)。あとは二つの枝に1か0を振って01で表現する
	★ある親が使用頻度の低い順2組に入らない場合、もうひとつの枝わかれが発生したような形になる。

BNF記法
	・::= 定義
	・|又は
	・<>記号
	★再帰的定義では、無限に呼び出しが続くためどこかで再帰を終わらせる必要がある

ポーランド逆記法
	値値符号の順に並べるだけ
	★()付きの場合は、()の後ろには値が来ないように前へ持っていける。(a-b) * c = (ab-)c* = abc+*


コンピューターの5大装置
	
	・CPU
		演算や制御を行う
	・メモリ
		主記憶装置。CPUとやり取りを行う
	・HDD/SSD
		補助記憶装置

	・ノイマン型PC
		プログラム内蔵式
			処理の際に補助記憶装置からメモリへプログラムを読み込む
		逐次制御
			CPUは命令を前から一つずつ実行する
CPU
	・レジスタ
		CPUが持つデータや命令を一時的に保存する記憶装置

	・命令実行手順
		命令取り出し(メモリから命令をとってきて命令レジスタ(命令部：オペランド部)へ記憶)
		→命令の解読→オペランド読み出し(必要なデータをメモリから汎用レジスタへ記憶）
		→命令実行(演算を行い演算結果を汎用レジスタへ記憶)
	
	・アドレス指定方式
		メモリからデータを取得する際に、どのようにメモリ上のアドレスを指定するか
		
		即値アドレス
			オペランド部の値をそのまま使用	
		直接アドレス
			オペランド部がメモリアドレスを指定
		間接アドレス
			オペランド部がメモリアドレスをもつメモリアドレスを指定
		インデックスレジスタ
			オペランド部 + インデックスレジスタでメモリアドレスを指定
		ベースレジスタ/プログラムカウンタ
			オペランド部 + ベースレジスタ(プログラムカウンタ)でメモリアドレスを指定、メモリ上の同じ箇所を指すためどのメモリアドレスにプログラムが展開されても同じものをとってくる

		